package arithmetic.aa202006.dynamicPlanning;


/**
 * Created by lidaxue on 2020/9/3.
 * leetcode : https://leetcode-cn.com/problems/unique-paths-ii/solution/
 *
 * 动态规划问题求解
 *
 * 该问题属于计数类问题
 * f(x,y) = {
 *     0  ;如果 u(x,y)坐标点为1
 *     f(x-1,y) + f(x,y-1);如果u(x,y)坐标点为0
 * }
 *
 * 空间复杂度优化：
 * 根据公式：我们应该需要 colLength * rowLength 的空间复杂度，首先我们计算的时候，是先计算第一行，然后第二行...直到最后一行
 * 但我们可以只用一个一维数组来存储，当计算到r行c列的时候，pathNumArr[c-1] 可以表示到达 obstacleGrid[c-1][r]点 上的路径数量
 * 假设列长度为 colLength ,行长度为rowLength
 *
 * 时间复杂度：O(colLength * rowLength)
 * 空间复杂度 O(colLength)
 */
public class PathSolutionOptimize {

    public static void main(String[] args) {
        int[][] obstacleGrid = {{0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1},{0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0},{0,0,0,0,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0},{1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0,1},{0,0,0,0,1,0,0,1,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0},{1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0},{0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1},{0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0},{1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},{0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0},{0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0},{0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0}};
        /*int[][] obstacleGrid = {
                {0, 0, 0},
                {0, 1, 0},
                {0, 0, 0}};*/
        PathSolutionOptimize pathSolution = new PathSolutionOptimize();
        int pathNum = pathSolution.uniquePathsWithObstacles(obstacleGrid);
        System.out.println("the pathNum is:"+pathNum);
    }
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

        if(obstacleGrid == null ||
           obstacleGrid.length==0 ||
           obstacleGrid[0].length==0){
            return 0;
        }
        //列数c
        int c = obstacleGrid.length;
        int r = obstacleGrid[0].length;
        int[] pathNumArr  = new int[c];
        solution(obstacleGrid,pathNumArr,c,r);
        return pathNumArr[c-1];
    }

    //c:列数;r行数
    private void solution(int[][] obstacleGrid,int[] pathNumArr,int cLength,int rLength){
        int num = 0;
         for(int row=0;row<rLength;row++){
             for(int col=0;col<cLength;col++){
                 if(obstacleGrid[col][row] == 1){
                    pathNumArr[col] = 0;
                 }else{
                     if(row==0 && col==0){
                         pathNumArr[col] = 1;
                     }else{
                         //{c-1,r} {c,r-1}
                         num = 0;
                         num += pathNumArr[col];
                         if(0<=col-1){
                             num += pathNumArr[col-1];
                         }
                         pathNumArr[col] = num;
                     }


                 }
             }
         }
    }
}
